<!doctype html>
<meta charset="utf-8"/>
<title>Flowchart Viewer - {{TIMESTAMP}}</title>
<style>
  body{font-family:Arial;margin:0;display:flex;height:100vh}
  #panel{width:400px;padding:10px;border-right:1px solid #ddd;background:#f7f7f7;box-sizing:border-box;overflow-y:auto}
  svg{flex:1;background:#fff}
  .meta-list{list-style:none;padding:0;margin:0 0 12px 0;font-size:11px;line-height:1.6;text-wrap:nowrap;overflow-x:scroll;}
  .node-rect{fill:#fff;stroke:#333;stroke-width:1.2;rx:6;ry:6}
  .node-label{font-size:12px;pointer-events:none}
  .node-label-action{font-weight:bold}
  .edgePath{stroke:#666;stroke-width:1.6;fill:none;marker-end:url(#arrow)}
  .edge-label{font-size:11px;font-weight:bold;fill:#0066cc;cursor:pointer;user-select:none;transition:all 0.2s}
  .edge-label:hover{fill:#ff0000;font-size:16px;font-weight:900}
  .info-section{margin-bottom:16px;padding:8px;background:#fff;border-radius:4px;overflow-x:auto}
  .info-title{font-weight:bold;margin-bottom:4px;color:#333}
  .info-content{font-size:12px;color:#666;word-break:break-all}
  .attr-item{padding:4px 0;border-bottom:1px solid #eee;font-size:12px}
  .attr-key{font-weight:600;color:#333}
  .tree-item{margin-left:16px;font-size:12px;white-space:nowrap}
  .tree-toggle{cursor:pointer;user-select:none;color:#0066cc;margin-right:4px;display:inline-block;width:12px}
  .tree-toggle:hover{color:#0044aa}
  .tree-key{font-weight:600;color:#333}
  .tree-value{color:#666}
  .tree-children{margin-left:16px;display:none}
  .tree-children.expanded{display:block}
  .tree-primitive{margin-left:16px}
  .filter-bar{margin-bottom:12px;padding:8px;background:#f0f0f0;border-radius:4px}
  .filter-input{width:100%;padding:6px;font-family:monospace;font-size:11px;border:1px solid #ccc;border-radius:3px;box-sizing:border-box}
  .filter-info{font-size:10px;color:#666;margin-top:4px}
  .filter-error{color:#c00;font-size:11px;margin-top:4px}
</style>

<div id=panel>
  <div style="margin-bottom:12px">
    <h3 style="margin:0 0 8px 0">Workflow Report</h3>
    <select id=graphSel style="width:100%;padding:4px"></select>
  </div>

  <ul class="meta-list">
    <li><b>Generated:</b> {{TIMESTAMP}}</li>
    <li><b>Workflow:</b> {{WORKFLOW_PATH}}</li>
    <li><b>Working Dir:</b> {{WORKING_DIR}}</li>
    {{VARIABLES}}
  </ul>

  <div style="margin:12px 0 8px 0;padding-top:12px;border-top:2px solid #ddd">
    <h4 style="margin:0 0 8px 0">Edge Data</h4>
    <ul class="meta-list" id="edgeInfo"></ul>
    <div class="filter-bar">
      <input type="text" class="filter-input" id="filterInput" placeholder="Filter: feature => feature.attributes.name === 'example'" value="f => " />
      <div class="filter-info">Enter JS expression. Press Enter to apply.</div>
      <div class="filter-error" id="filterError"></div>
    </div>
  </div>

  <div id="featureList"></div>
</div>

<svg id=svg></svg>

<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>

<script>
const workflowDoc = JSON.parse(`{{WORKFLOW_JSON}}`);
const edgeDataMap = JSON.parse(`{{EDGE_DATA}}`);
const graphSel = document.getElementById('graphSel');
const edgeInfo = document.getElementById('edgeInfo');
const featureList = document.getElementById('featureList');
const filterInput = document.getElementById('filterInput');
const filterError = document.getElementById('filterError');
const svg = d3.select('#svg');
let currentEdgeId = null;
let currentFeatures = [];
let displayedCount = 0;
const BATCH_SIZE = 50;

function updateSvgSize(){
  const w = window.innerWidth - 400;
  svg.attr('width', w).attr('height', window.innerHeight);
}
updateSvgSize();

async function loadEdgeData(edgeId){
  const edgeData = edgeDataMap[edgeId];
  if(!edgeData){
    edgeInfo.innerHTML = '<li>No data available</li>';
    featureList.innerHTML = '';
    return;
  }

  // Show loading state
  edgeInfo.innerHTML = `<li>Edge ID: ${edgeId}</li><li>Loading ${edgeData.count} features...</li>`;
  featureList.innerHTML = '';

  try {
    // Fetch JSONL file dynamically
    const response = await fetch(edgeData.file_path);
    if(!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

    const content = await response.text();
    const lines = content.trim().split('\n');
    const features = lines.map(l=>JSON.parse(l));
    currentEdgeId = edgeId;
    currentFeatures = features;
    filterError.textContent = '';

    // Apply current filter if any
    applyFilter();
  } catch(err) {
    edgeInfo.innerHTML = `<li>Error loading data: ${err.message}</li><li>File: ${edgeData.file_path}</li>`;
    featureList.innerHTML = '';
  }
}

function applyFilter(){
  const filterCode = filterInput.value.trim();
  filterError.textContent = '';

  if(!filterCode){
    displayEdgeData(currentEdgeId, currentFeatures.map((f, i) => ({feature: f, originalIndex: i})));
    return;
  }

  try {
    let filterFn;
    if(filterCode.includes('=>')){
      filterFn = eval(`(${filterCode})`);
    } else {
      filterFn = eval(`(f => ${filterCode})`);
    }

    const filtered = currentFeatures
      .map((f, i) => ({feature: f, originalIndex: i}))
      .filter(item => filterFn(item.feature));
    displayEdgeData(currentEdgeId, filtered);
  } catch(err) {
    filterError.textContent = `Error: ${err.message}`;
    // On error, show all edges
    displayEdgeData(currentEdgeId, currentFeatures.map((f, i) => ({feature: f, originalIndex: i})));
  }
}

filterInput.addEventListener('keydown', (e) => {
  if(e.key === 'Enter'){
    applyFilter();
  }
});

function renderTreeValue(value, path = '', depth = 0) {
  const uniqueId = `tree-${path}-${Math.random().toString(36).substr(2, 9)}`;
  const shouldExpand = depth <= 1;

  if (value === null || value === undefined) {
    return `<span class="tree-value">null</span>`;
  }

  if (typeof value === 'object' && !Array.isArray(value)) {
    const keys = Object.keys(value);
    if (keys.length === 0) {
      return `<span class="tree-value">{}</span>`;
    }
    let html = `<div class="tree-item">
      <span class="tree-toggle" onclick="toggleTree('${uniqueId}')">${shouldExpand ? '▼' : '▶'}</span>
      <span class="tree-value">{${keys.length}}</span>
      <div class="tree-children${shouldExpand ? ' expanded' : ''}" id="${uniqueId}">`;
    for (const [k, v] of Object.entries(value)) {
      html += `<div><span class="tree-key">${k}:</span> ${renderTreeValue(v, path + '.' + k, depth + 1)}</div>`;
    }
    html += `</div></div>`;
    return html;
  }

  if (Array.isArray(value)) {
    if (value.length === 0) {
      return `<span class="tree-value">[]</span>`;
    }
    let html = `<div class="tree-item">
      <span class="tree-toggle" onclick="toggleTree('${uniqueId}')">${shouldExpand ? '▼' : '▶'}</span>
      <span class="tree-value">[${value.length}]</span>
      <div class="tree-children${shouldExpand ? ' expanded' : ''}" id="${uniqueId}">`;
    value.forEach((v, idx) => {
      html += `<div><span class="tree-key">[${idx}]:</span> ${renderTreeValue(v, path + '[' + idx + ']', depth + 1)}</div>`;
    });
    html += `</div></div>`;
    return html;
  }

  if (typeof value === 'string') {
    const displayValue = value.length > 100 ? value.substring(0, 100) + '...' : value;
    return `<span class="tree-value">"${displayValue}"</span>`;
  }

  return `<span class="tree-value">${value}</span>`;
}

function toggleTree(id) {
  const element = document.getElementById(id);
  const toggle = element.previousElementSibling.previousElementSibling;
  if (element.classList.contains('expanded')) {
    element.classList.remove('expanded');
    toggle.textContent = '▶';
  } else {
    element.classList.add('expanded');
    toggle.textContent = '▼';
  }
}

let currentDisplayFeatures = [];

function displayEdgeData(edgeId, featuresWithIndices){
  currentDisplayFeatures = featuresWithIndices;
  displayedCount = 0;

  const totalCount = currentFeatures.length;
  const filteredCount = featuresWithIndices.length;
  const countText = filteredCount < totalCount ? `${filteredCount} / ${totalCount}` : `${totalCount}`;

  edgeInfo.innerHTML = `<li>Edge ID: ${edgeId}</li><li>Feature Count: ${countText}</li>`;
  featureList.innerHTML = '';

  loadMoreFeatures();
}

function loadMoreFeatures(){
  if(!featureList) return;

  const endIndex = Math.min(displayedCount + BATCH_SIZE, currentDisplayFeatures.length);
  let html = '';

  for(let idx = displayedCount; idx < endIndex; idx++){
    const item = currentDisplayFeatures[idx];
    const originalIdx = item.originalIndex;
    const feature = item.feature;
    html += `<div class="info-section">
      <div class="info-title">Feature #${originalIdx + 1}</div>`;
    html += renderTreeValue(feature, `feature-${originalIdx}`);
    html += `</div>`;
  }

  featureList.insertAdjacentHTML('beforeend', html);
  displayedCount = endIndex;

  // Remove old load more button if exists
  const oldBtn = document.getElementById('loadMoreBtn');
  if(oldBtn) oldBtn.remove();

  // Add load more button if there are more features
  if(displayedCount < currentDisplayFeatures.length){
    const remaining = currentDisplayFeatures.length - displayedCount;
    featureList.insertAdjacentHTML('beforeend',
      `<div class="info-section" style="text-align:center">
        <button id="loadMoreBtn" onclick="loadMoreFeatures()" style="padding:8px 16px;cursor:pointer">
          Load More (${remaining} remaining)
        </button>
      </div>`);
  }
}

function findGraphs(doc){
  if(!doc) return [];
  if(Array.isArray(doc.graphs)) return doc.graphs;
  if(doc.nodes && doc.edges) return [doc];
  return [];
}

function layoutAndRender(graph){
  svg.selectAll('*').remove();
  const container = svg.append('g');
  const zoom = d3.zoom()
    .filter(event => event.type === 'wheel' || (event.type === 'mousedown' && event.button === 1) || event.type === 'touchstart')
    .scaleExtent([0.2,3])
    .on('zoom', e => container.attr('transform', e.transform));
  svg.call(zoom);
  svg.append('defs').html('<marker id="arrow" viewBox="0 -5 10 10" refX="20" refY="0" markerWidth="6" markerHeight="6" orient="auto"><path d="M0,-5L10,0L0,5" fill="#666"/></marker>');
  const g = new dagre.graphlib.Graph({multigraph: true})
    .setGraph({rankdir:'TB', nodesep: 40, ranksep: 80})
    .setDefaultEdgeLabel(()=>{});
  for (const n of graph.nodes||[]) {
    const name = n.name || n.id;
    const action = n.action || '';
    const width = Math.max(100, Math.max(name.length, action.length) * 6 + 20);
    g.setNode(n.id, {label: name + '\n' + action, width, height: 40, name, action});
  }
  for (const e of graph.edges||[]) {
    g.setEdge(e.from, e.to, {edgeId: e.id}, e.id);
  }
  dagre.layout(g);

  // Calculate bounding box for centering
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const id of g.nodes()) {
    const nd = g.node(id);
    minX = Math.min(minX, nd.x - nd.width/2);
    minY = Math.min(minY, nd.y - nd.height/2);
    maxX = Math.max(maxX, nd.x + nd.width/2);
    maxY = Math.max(maxY, nd.y + nd.height/2);
  }

  for (const e of g.edges()) {
    const ed = g.edge(e);
    const edgeId = ed.edgeId;
    const edgeData = edgeDataMap[edgeId];
    container.append('path')
      .attr('class', 'edgePath')
      .attr('d', lineFromPoints(ed.points));
    if(edgeData){
      const mid = ed.points[Math.floor(ed.points.length/2)];
      container.append('text')
        .attr('class', 'edge-label')
        .attr('x', mid.x)
        .attr('y', mid.y)
        .attr('text-anchor', 'middle')
        .text(edgeData.count)
        .on('click', ()=>{
          loadEdgeData(edgeId);
        });
    }
  }
  for (const id of g.nodes()) {
    const nd = g.node(id);
    const nodeG = container.append('g')
      .attr('class', 'node')
      .attr('transform', `translate(${nd.x},${nd.y})`);
    nodeG.append('rect')
      .attr('x', -nd.width/2)
      .attr('y', -nd.height/2)
      .attr('width', nd.width)
      .attr('height', nd.height)
      .attr('class', 'node-rect');
    const text = nodeG.append('text')
      .attr('text-anchor', 'middle')
      .attr('class', 'node-label');
    text.append('tspan')
      .attr('x', 0)
      .attr('dy', '-0.5em')
      .text(nd.name);
    text.append('tspan')
      .attr('x', 0)
      .attr('dy', '1em')
      .attr('class', 'node-label-action')
      .text(nd.action);
  }
  function lineFromPoints(points){
    if(!points || points.length===0) return '';
    return points.map((p,i)=> (i===0? 'M':'L') + p.x + ',' + p.y).join(' ');
  }

  // Center the graph in the viewport
  const graphWidth = maxX - minX;
  const graphHeight = maxY - minY;
  const svgWidth = +svg.attr('width');
  const svgHeight = +svg.attr('height');

  const scale = Math.min(
    svgWidth / (graphWidth + 100),
    svgHeight / (graphHeight + 100),
    1
  );

  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  const translateX = svgWidth / 2 - centerX * scale;
  const translateY = svgHeight / 2 - centerY * scale;

  svg.call(zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(scale));
}

const graphs = findGraphs(workflowDoc);
if(graphs.length > 0) {
  graphs.forEach((g,i)=>{
    const o = document.createElement('option');
    o.value=i;
    o.text = g.name||g.id||'graph#'+(i+1);
    graphSel.add(o);
  });
  layoutAndRender(graphs[0]);
  graphSel.onchange = ()=> layoutAndRender(graphs[+graphSel.value]);
}
</script>
